[Hit(uuid='0',
     path='/lib/dblayer/model/query.py',
     lineno=9,
     depth=1,
     type='class',
     name='Query',
     text='class Query(table.Table):\n'
          '    """ Query\n'
          '    """\n'
          '    # Queries need not be created and cannot be written\n'
          '    _creatable = False\n'
          '    _writable = False\n'
          '\n'
          '    # Mapping of alias names to the source Table instances\n'
          '    # NOTE: Filled in by the __new__ class method\n'
          '    _table_map = None\n'
          '\n'
          '    # Conditions\n'
          '    # NOTE: Filled in by the __new__ class method\n'
          '    _condition_list = ()\n'
          '\n'
          '    # Group by expressions (override in your subclass)\n'
          '    _group_by = ()\n'
          '\n'
          '    # Ordering expressions (override in your subclass)\n'
          '    _order_by = ()\n'
          '\n'
          '    def __new__(cls):\n'
          '        # Initialize the class only once\n'
          '        if not cls._initialized:\n'
          '            cls.initialize()\n'
          '\n'
          '        return super(Query, cls).__new__(cls)\n'
          '\n'
          '    @classmethod\n'
          '    def initialize(cls):\n'
          '\n'
          '        # Mark the class as initialized\n'
          "        # NOTE: It prevent Table's initialization from being "
          'executed, it is intentional\n'
          '        cls._initialized = True\n'
          '\n'
          '        # Collect objects from the class definition\n'
          '        cls._collect_result_condition_list()\n'
          '\n'
          '    @classmethod\n'
          '    def _collect_result_condition_list(cls):\n'
          '        """ Collects the result column and condition definitions '
          'from the model class\n'
          '        """\n'
          '        cls._table_map = {}\n'
          '        cls._column_list = []\n'
          '        cls._condition_list = []\n'
          '        for name in dir(cls):\n'
          '            value = getattr(cls, name)\n'
          '\n'
          '            if isinstance(value, table.Table):\n'
          '                value._name = name\n'
          '                cls._table_map[name] = value\n'
          '\n'
          '            elif isinstance(value, Result):\n'
          '                value.table_class = cls\n'
          '                value.name = name\n'
          '                cls._column_list.append(value)\n'
          '\n'
          '            elif isinstance(value, Condition):\n'
          '                value.table_class = cls\n'
          '                value.name = name\n'
          '                cls._condition_list.append(value)\n'
          '\n'
          '        # Sort them by definition order\n'
          '        cls._column_list.sort(key=column.BaseColumn.sort_key)\n'
          '        cls._condition_list.sort(key=Condition.sort_key)\n'
          '\n'
          '    def __repr__(self):\n'
          "        return '<Query: %s>' % self._name\n"
          '\n'
          '    __str__ = __repr__\n'
          '\n'
          '    def get_table_list(self):\n'
          '        """ Returns the table list for the clauses of the SELECT '
          'statement\n'
          '        \n'
          '        Items of the returned list can be either:\n'
          '        \n'
          '        (table_name, alias_name) to start a new cross join group '
          'or\n'
          '        (table_name, alias_name, join_type, id_field_name, '
          'referer_table_name, fk_field_name) to continue one.\n'
          '        \n'
          '        Unaliased tables are not used here.\n'
          '        \n'
          '        """\n'
          '        table_map = self._table_map.copy()\n'
          '\n'
          '        def iterate_joined_tables(referer, visited):\n'
          '            """ Appends tables referenced from the given table to '
          'the table list\n'
          '            """\n'
          '            # Iterate on all the tables remained in the table map\n'
          '            for alias_name, table in table_map.items():\n'
          '\n'
          '                # Determine the referer table for this table in the '
          'JOIN chain\n'
          '                foreign_key = table._referer\n'
          '                referer_table = foreign_key.table if foreign_key '
          'else None\n'
          '\n'
          "                # Is the referer the table we're looking for?\n"
          '                if referer_table is referer and alias_name not in '
          'visited:\n'
          '\n'
          '                    # Consider each table only once\n'
          '                    visited.add(alias_name)\n'
          '\n'
          '                    # Construct table list item\n'
          '                    if referer is None:\n'
          '                        item = (\n'
          '                            # Database table name, not the alias in '
          'this query\n'
          '                            table._table_name,\n'
          '                            # Alias name in this query for this '
          'table\n'
          '                            alias_name)\n'
          '                    else:\n'
          '                        join_type = constants.LEFT_JOIN if '
          'foreign_key.null else constants.INNER_JOIN\n'
          '                        item = (\n'
          '                            # Database table name, not the alias in '
          'this query\n'
          '                            table._table_name,\n'
          '                            # Alias name in this query for this '
          'table\n'
          '                            alias_name,\n'
          '                            # Type of this joine, like INNER JOIN '
          'or LEFT JOIN\n'
          '                            join_type,\n'
          '                            # Name of the primary key column in the '
          'joined table\n'
          '                            table._primary_key.name,\n'
          '                            # Alias name of the referer (already '
          'joined) table\n'
          '                            referer_table._name,\n'
          '                            # Name of the referer foreign key '
          'column in the referer (already joined) table\n'
          '                            foreign_key.name)\n'
          '\n'
          '                    if constants.DEBUG:\n'
          '                        assert not sum(1 for x in item if not x), '
          "'Empty name(s) in join definition item: %r' % (item,)\n"
          '\n'
          '                    # Yield table list item\n'
          '                    yield item\n'
          '\n'
          '                    # Find all the referer tables below this point '
          'in the tree\n'
          '                    for item in iterate_joined_tables(table, '
          'visited):\n'
          '                        yield item\n'
          '\n'
          '        visited = set()\n'
          '        table_list = list(iterate_joined_tables(None, visited))\n'
          '        assert len(visited) == len(table_map)\n'
          '\n'
          '        return table_list\n'
          '\n'
          '    @classmethod\n'
          '    def pretty_format_class(cls):\n'
          '        """ Formats source code defining the query\n'
          '        """\n'
          '        if not cls._initialized:\n'
          '            cls.initialize()\n'
          '\n'
          "        line_list = ['class %s(query.Query):' % cls.__name__]\n"
          '        append_line = line_list.append\n'
          '\n'
          '        if cls.__doc__:\n'
          "            if '\\n' in cls.__doc__:\n"
          '                append_line(\'    """%s"""\' % cls.__doc__)\n'
          '            else:\n'
          '                append_line(\'    """ %s """\' % '
          'cls.__doc__.strip())\n'
          '        else:\n'
          "            append_line('')\n"
          '\n'
          '        for alias, table in sorted(cls._table_map.items()):\n'
          "            append_line('    %s = %s()' % (alias, "
          'table.__class__.__name__))\n'
          "        append_line('')\n"
          '\n'
          '        for obj in cls._column_list:\n'
          "            append_line('    %s = %s' % (obj.name, "
          'obj.full_repr()))\n'
          '\n'
          "        append_line('')\n"
          '\n'
          '        for obj in cls._condition_list:\n'
          "            append_line('    %s = %s' % (obj.name, "
          'obj.full_repr()))\n'
          '\n'
          "        append_line('')\n"
          '\n'
          '        if cls._group_by:\n'
          "            append_line('    _group_by = %r' % (cls._group_by,))\n"
          '\n'
          '        if cls._order_by:\n'
          "            append_line('    _order_by = %r' % (cls._order_by,))\n"
          '\n'
          '        for i in range(len(line_list) - 1, 1, -1):\n'
          '            if not line_list[i] and not line_list[i - 1]:\n'
          '                del line_list[i]\n'
          '\n'
          "        return '\\n'.join(line_list)",
     tokens=1308,
     score=1.0),
 Hit(uuid='1',
     path='/lib/dblayer/backend/base/format.py',
     lineno=1477,
     depth=1,
     type='function',
     name='format_query',
     text='def format_query(\n'
          '        table_list,\n'
          '        field_list,\n'
          '        where_condition_map,\n'
          '        having_condition_map,\n'
          '        group_by,\n'
          '        order_by_map,\n'
          '        runtime_where_condition,\n'
          '        runtime_having_condition,\n'
          '        runtime_conditions,\n'
          '        order_by,\n'
          '        limit,\n'
          '        offset):\n'
          '    """ Formats a SELECT SQL statement at runtime for the actual '
          'conditions\n'
          '    \n'
          '    Returns (sql, parameter_tuple)\n'
          '    \n'
          '    Partial caching is done by the format_select function, but the '
          'evaluation\n'
          '    of the dynamic conditions cannot be cached. The actual runtime '
          'conditions\n'
          '    are the keywords parameters passed to the query method on the '
          'database\n'
          '    abstraction layer.\n'
          '    \n'
          '    Passing a tuple in the order_by parameter defines the record '
          'ordering.\n'
          "    Values can be condition names. Use '-' prefix for descending "
          'sort.\n'
          "    You can also use a redundant '+' prefix for ascending short.\n"
          '    \n'
          '    """\n'
          '    if constants.DEBUG:\n'
          '        assert isinstance(runtime_conditions, dict)\n'
          '        assert isinstance(where_condition_map, dict)\n'
          '        assert isinstance(having_condition_map, dict)\n'
          '        assert isinstance(group_by, (tuple, list))\n'
          '\n'
          '    # Parse keyword parameters (actual runtime conditions) passed\n'
          '    where = []\n'
          '    having = []\n'
          '    parameter_list = []\n'
          '    for name, value in runtime_conditions.items():\n'
          '\n'
          '        if value is NA:\n'
          '            continue\n'
          '\n'
          '        # Find the condition by name\n'
          '        condition = where_condition_map.get(name)\n'
          '        if condition:\n'
          '            clause = where\n'
          '        else:\n'
          '            condition = having_condition_map.get(name)\n'
          '            if condition:\n'
          '                clause = having\n'
          '            else:\n'
          '                raise TypeError(\n'
          "                    'Query method received unknown condition: "
          "%s=%r' %\n"
          '                    (name, value))\n'
          '\n'
          '        # Format the condition\n'
          '        suffix, formatting_function, value_expression = condition\n'
          '        sql_expression, sql_parameters = '
          'formatting_function(value_expression, value)\n'
          '\n'
          '        # Append it to the clause\n'
          '        clause.append(sql_expression)\n'
          '        parameter_list.extend(sql_parameters)\n'
          '\n'
          '    # Where condition built up runtime\n'
          '    if runtime_where_condition is not None:\n'
          '        sql_expression = '
          'format_expression(runtime_where_condition)\n'
          '        where.append(sql_expression)\n'
          '\n'
          '    # Having condition built up runtime\n'
          '    if runtime_having_condition is not None:\n'
          '        sql_expression = '
          'format_expression(runtime_having_condition)\n'
          '        having.append(sql_expression)\n'
          '\n'
          '    # Join the conditions together\n'
          "    where = ' AND '.join(where)\n"
          "    having = ' AND '.join(having)\n"
          '\n'
          '    # NOTE: The group_by expressions are formatted while the '
          'abstraction layer is generated.\n'
          '\n'
          '    # Format order by items\n'
          '    formatted_order_by = format_order_by(order_by_map, order_by)\n'
          '\n'
          '    clauses = dblayer.backend.base.clauses.Clauses(\n'
          '        table_list=table_list,\n'
          '        field_list=field_list,\n'
          '        where=where,\n'
          '        group_by=group_by,\n'
          '        having=having,\n'
          '        order_by=formatted_order_by,\n'
          '        limit=limit,\n'
          '        offset=offset)\n'
          '\n'
          '    return (format_select(clauses), tuple(parameter_list))',
     tokens=593,
     score=0.5)]