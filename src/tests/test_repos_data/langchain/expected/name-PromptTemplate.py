[Hit(uuid='0',
     path='/langchain/prompts/prompt.py',
     lineno=18,
     depth=1,
     type='class',
     name='PromptTemplate',
     text='class PromptTemplate(StringPromptTemplate):\n'
          '    """Schema to represent a prompt for an LLM.\n'
          '\n'
          '    Example:\n'
          '        .. code-block:: python\n'
          '\n'
          '            from langchain import PromptTemplate\n'
          '            prompt = PromptTemplate(input_variables=["foo"], '
          'template="Say {foo}")\n'
          '    """\n'
          '\n'
          '    @property\n'
          '    def lc_attributes(self) -> Dict[str, Any]:\n'
          '        return {\n'
          '            "template_format": self.template_format,\n'
          '        }\n'
          '\n'
          '    input_variables: List[str]\n'
          '    """A list of the names of the variables the prompt template '
          'expects."""\n'
          '\n'
          '    template: str\n'
          '    """The prompt template."""\n'
          '\n'
          '    template_format: str = "f-string"\n'
          '    """The format of the prompt template. Options are: '
          '\'f-string\', \'jinja2\'."""\n'
          '\n'
          '    validate_template: bool = True\n'
          '    """Whether or not to try validating the template."""\n'
          '\n'
          '    @property\n'
          '    def _prompt_type(self) -> str:\n'
          '        """Return the prompt type key."""\n'
          '        return "prompt"\n'
          '\n'
          '    class Config:\n'
          '        """Configuration for this pydantic object."""\n'
          '\n'
          '        extra = Extra.forbid\n'
          '\n'
          '    def format(self, **kwargs: Any) -> str:\n'
          '        """Format the prompt with the inputs.\n'
          '\n'
          '        Args:\n'
          '            kwargs: Any arguments to be passed to the prompt '
          'template.\n'
          '\n'
          '        Returns:\n'
          '            A formatted string.\n'
          '\n'
          '        Example:\n'
          '\n'
          '        .. code-block:: python\n'
          '\n'
          '            prompt.format(variable1="foo")\n'
          '        """\n'
          '        kwargs = self._merge_partial_and_user_variables(**kwargs)\n'
          '        return '
          'DEFAULT_FORMATTER_MAPPING[self.template_format](self.template, '
          '**kwargs)\n'
          '\n'
          '    @root_validator()\n'
          '    def template_is_valid(cls, values: Dict) -> Dict:\n'
          '        """Check that template and input variables are '
          'consistent."""\n'
          '        if values["validate_template"]:\n'
          '            all_inputs = values["input_variables"] + '
          'list(values["partial_variables"])\n'
          '            check_valid_template(\n'
          '                values["template"], values["template_format"], '
          'all_inputs\n'
          '            )\n'
          '        return values\n'
          '\n'
          '    @classmethod\n'
          '    def from_examples(\n'
          '        cls,\n'
          '        examples: List[str],\n'
          '        suffix: str,\n'
          '        input_variables: List[str],\n'
          '        example_separator: str = "\\n\\n",\n'
          '        prefix: str = "",\n'
          '        **kwargs: Any,\n'
          '    ) -> PromptTemplate:\n'
          '        """Take examples in list format with prefix and suffix to '
          'create a prompt.\n'
          '\n'
          '        Intended to be used as a way to dynamically create a prompt '
          'from examples.\n'
          '\n'
          '        Args:\n'
          '            examples: List of examples to use in the prompt.\n'
          '            suffix: String to go after the list of examples. Should '
          'generally\n'
          "                set up the user's input.\n"
          '            input_variables: A list of variable names the final '
          'prompt template\n'
          '                will expect.\n'
          '            example_separator: The separator to use in between '
          'examples. Defaults\n'
          '                to two new line characters.\n'
          '            prefix: String that should go before any examples. '
          'Generally includes\n'
          '                examples. Default to an empty string.\n'
          '\n'
          '        Returns:\n'
          '            The final prompt generated.\n'
          '        """\n'
          '        template = example_separator.join([prefix, *examples, '
          'suffix])\n'
          '        return cls(input_variables=input_variables, '
          'template=template, **kwargs)\n'
          '\n'
          '    @classmethod\n'
          '    def from_file(\n'
          '        cls, template_file: Union[str, Path], input_variables: '
          'List[str], **kwargs: Any\n'
          '    ) -> PromptTemplate:\n'
          '        """Load a prompt from a file.\n'
          '\n'
          '        Args:\n'
          '            template_file: The path to the file containing the '
          'prompt template.\n'
          '            input_variables: A list of variable names the final '
          'prompt template\n'
          '                will expect.\n'
          '        Returns:\n'
          '            The prompt loaded from the file.\n'
          '        """\n'
          '        with open(str(template_file), "r") as f:\n'
          '            template = f.read()\n'
          '        return cls(input_variables=input_variables, '
          'template=template, **kwargs)\n'
          '\n'
          '    @classmethod\n'
          '    def from_template(cls, template: str, **kwargs: Any) -> '
          'PromptTemplate:\n'
          '        """Load a prompt template from a template."""\n'
          '        if "template_format" in kwargs and '
          'kwargs["template_format"] == "jinja2":\n'
          '            # Get the variables for the template\n'
          '            input_variables = '
          '_get_jinja2_variables_from_template(template)\n'
          '\n'
          '        else:\n'
          '            input_variables = {\n'
          '                v for _, v, _, _ in Formatter().parse(template) if '
          'v is not None\n'
          '            }\n'
          '\n'
          '        if "partial_variables" in kwargs:\n'
          '            partial_variables = kwargs["partial_variables"]\n'
          '            input_variables = {\n'
          '                var for var in input_variables if var not in '
          'partial_variables\n'
          '            }\n'
          '\n'
          '        return cls(\n'
          '            input_variables=list(sorted(input_variables)), '
          'template=template, **kwargs\n'
          '        )',
     tokens=915,
     score=1.0),
 Hit(uuid='1',
     path='/langchain/prompts/base.py',
     lineno=104,
     depth=1,
     type='class',
     name='BasePromptTemplate',
     text='class BasePromptTemplate(Serializable, ABC):\n'
          '    """Base class for all prompt templates, returning a prompt."""\n'
          '\n'
          '    input_variables: List[str]\n'
          '    """A list of the names of the variables the prompt template '
          'expects."""\n'
          '    output_parser: Optional[BaseOutputParser] = None\n'
          '    """How to parse the output of calling an LLM on this formatted '
          'prompt."""\n'
          '    partial_variables: Mapping[str, Union[str, Callable[[], str]]] '
          '= Field(\n'
          '        default_factory=dict\n'
          '    )\n'
          '\n'
          '    @property\n'
          '    def lc_serializable(self) -> bool:\n'
          '        return True\n'
          '\n'
          '    class Config:\n'
          '        """Configuration for this pydantic object."""\n'
          '\n'
          '        extra = Extra.forbid\n'
          '        arbitrary_types_allowed = True\n'
          '\n'
          '    @abstractmethod\n'
          '    def format_prompt(self, **kwargs: Any) -> PromptValue:\n'
          '        """Create Chat Messages."""\n'
          '\n'
          '    @root_validator()\n'
          '    def validate_variable_names(cls, values: Dict) -> Dict:\n'
          '        """Validate variable names do not include restricted '
          'names."""\n'
          '        if "stop" in values["input_variables"]:\n'
          '            raise ValueError(\n'
          '                "Cannot have an input variable named \'stop\', as '
          'it is used internally,"\n'
          '                " please rename."\n'
          '            )\n'
          '        if "stop" in values["partial_variables"]:\n'
          '            raise ValueError(\n'
          '                "Cannot have an partial variable named \'stop\', as '
          'it is used "\n'
          '                "internally, please rename."\n'
          '            )\n'
          '\n'
          '        overall = set(values["input_variables"]).intersection(\n'
          '            values["partial_variables"]\n'
          '        )\n'
          '        if overall:\n'
          '            raise ValueError(\n'
          '                f"Found overlapping input and partial variables: '
          '{overall}"\n'
          '            )\n'
          '        return values\n'
          '\n'
          '    def partial(self, **kwargs: Union[str, Callable[[], str]]) -> '
          'BasePromptTemplate:\n'
          '        """Return a partial of the prompt template."""\n'
          '        prompt_dict = self.__dict__.copy()\n'
          '        prompt_dict["input_variables"] = list(\n'
          '            set(self.input_variables).difference(kwargs)\n'
          '        )\n'
          '        prompt_dict["partial_variables"] = '
          '{**self.partial_variables, **kwargs}\n'
          '        return type(self)(**prompt_dict)\n'
          '\n'
          '    def _merge_partial_and_user_variables(self, **kwargs: Any) -> '
          'Dict[str, Any]:\n'
          '        # Get partial params:\n'
          '        partial_kwargs = {\n'
          '            k: v if isinstance(v, str) else v()\n'
          '            for k, v in self.partial_variables.items()\n'
          '        }\n'
          '        return {**partial_kwargs, **kwargs}\n'
          '\n'
          '    @abstractmethod\n'
          '    def format(self, **kwargs: Any) -> str:\n'
          '        """Format the prompt with the inputs.\n'
          '\n'
          '        Args:\n'
          '            kwargs: Any arguments to be passed to the prompt '
          'template.\n'
          '\n'
          '        Returns:\n'
          '            A formatted string.\n'
          '\n'
          '        Example:\n'
          '\n'
          '        .. code-block:: python\n'
          '\n'
          '            prompt.format(variable1="foo")\n'
          '        """\n'
          '\n'
          '    @property\n'
          '    def _prompt_type(self) -> str:\n'
          '        """Return the prompt type key."""\n'
          '        raise NotImplementedError\n'
          '\n'
          '    def dict(self, **kwargs: Any) -> Dict:\n'
          '        """Return dictionary representation of prompt."""\n'
          '        prompt_dict = super().dict(**kwargs)\n'
          '        prompt_dict["_type"] = self._prompt_type\n'
          '        return prompt_dict\n'
          '\n'
          '    def save(self, file_path: Union[Path, str]) -> None:\n'
          '        """Save the prompt.\n'
          '\n'
          '        Args:\n'
          '            file_path: Path to directory to save prompt to.\n'
          '\n'
          '        Example:\n'
          '        .. code-block:: python\n'
          '\n'
          '            prompt.save(file_path="path/prompt.yaml")\n'
          '        """\n'
          '        if self.partial_variables:\n'
          '            raise ValueError("Cannot save prompt with partial '
          'variables.")\n'
          '        # Convert file to Path object.\n'
          '        if isinstance(file_path, str):\n'
          '            save_path = Path(file_path)\n'
          '        else:\n'
          '            save_path = file_path\n'
          '\n'
          '        directory_path = save_path.parent\n'
          '        directory_path.mkdir(parents=True, exist_ok=True)\n'
          '\n'
          '        # Fetch dictionary to save\n'
          '        prompt_dict = self.dict()\n'
          '\n'
          '        if save_path.suffix == ".json":\n'
          '            with open(file_path, "w") as f:\n'
          '                json.dump(prompt_dict, f, indent=4)\n'
          '        elif save_path.suffix == ".yaml":\n'
          '            with open(file_path, "w") as f:\n'
          '                yaml.dump(prompt_dict, f, '
          'default_flow_style=False)\n'
          '        else:\n'
          '            raise ValueError(f"{save_path} must be json or yaml")',
     tokens=862,
     score=0.5)]